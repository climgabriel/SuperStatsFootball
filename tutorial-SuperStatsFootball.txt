    SUPERSTATS FOOTBALL - COMPLETE BUILD GUIDE (HIGH-PERFORMANCE CLONE)

ğŸ¯ GOAL: Build a production-ready clone of www.superstatsfootball.com
ğŸ“… Target: Windows + Docker deployment to GreenGeeks
âš¡ Performance: Real-time stats, optimized queries, scalable architecture

TABLE OF CONTENTS

PART 1: ARCHITECTURE & PLANNING
  1.1 System Architecture Overview
  1.2 Technology Stack
  1.3 Database Schema Design
  1.4 API Design
  1.5 Tiered Access Model

PART 2: ENVIRONMENT SETUP
  2.1 Windows Prerequisites
  2.2 Docker Desktop Installation
  2.3 Development Tools Setup
  2.4 Supabase Account & Project Setup

PART 3: BACKEND DEVELOPMENT (FASTAPI)
  3.1 Project Structure
  3.2 FastAPI Application Setup
  3.3 Database Models & ORM (SQLAlchemy)
  3.4 Authentication & Authorization
  3.5 API Endpoints Design

PART 4: APIFOOTBALL INTEGRATION
  4.1 API-Football Account Setup
  4.2 Historical Data Ingestion
  4.3 Fixtures Data Management
  4.4 Live Stats Polling (1-second intervals)
  4.5 Rate Limiting & Caching Strategy

PART 5: DATABASE (SUPABASE/POSTGRESQL)
  5.1 Schema Implementation
  5.2 Row Level Security (RLS) Rules
  5.3 Realtime Configuration
  5.4 Indexes & Performance Optimization
  5.5 Backup Strategy

PART 6: STATISTICAL MODELS (USER FEATURES)
  6.1 Poisson Distribution Model
  6.2 Dixon-Coles Model
  6.3 Elo Rating System
  6.4 Logistic Regression Predictions
  6.5 Model Comparison & Validation

PART 7: ML MODELS (ADMIN FEATURES)
  7.1 Feature Engineering Pipeline
  7.2 Random Forest Implementation
  7.3 XGBoost Model Training
  7.4 Model Evaluation & Monitoring
  7.5 Prediction API Endpoints

PART 8: FRONTEND DEVELOPMENT (REACT)
  8.1 React + Vite Setup
  8.2 Tailwind CSS Configuration
  8.3 Component Architecture
  8.4 State Management (Zustand/Redux)
  8.5 UI/UX Implementation

PART 9: KEY FEATURES IMPLEMENTATION
  9.1 Settings & Filters Panel
  9.2 Clear/Reset Functionality
  9.3 "Only Next Round" Fixtures Display
  9.4 Real-time Stats Updates
  9.5 Admin Debug Panel

PART 10: TIERED ACCESS SYSTEM
  10.1 Subscription Plans Design
  10.2 Payment Integration (Stripe)
  10.3 League Coverage Per Tier
  10.4 Feature Gating Implementation
  10.5 User Dashboard

PART 11: DOCKER & DEPLOYMENT
  11.1 Dockerfile Creation
  11.2 Docker Compose Configuration
  11.3 Environment Variables Management
  11.4 CI/CD Pipeline Setup
  11.5 GreenGeeks Deployment

PART 12: MONITORING & MAINTENANCE
  12.1 Logging Strategy
  12.2 Error Tracking (Sentry)
  12.3 Performance Monitoring
  12.4 Database Maintenance
  12.5 Backup & Recovery

PART 1: ARCHITECTURE & PLANNING

1.1 SYSTEM ARCHITECTURE OVERVIEW
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                           USER INTERFACE                                 â”‚
â”‚                   (React + Tailwind + TypeScript)                        â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”‚
â”‚  â”‚  Fixtures  â”‚  â”‚ Statistics â”‚  â”‚  Settings  â”‚  â”‚  Admin     â”‚       â”‚
â”‚  â”‚  Display   â”‚  â”‚ Dashboard  â”‚  â”‚  & Filters â”‚  â”‚  Panel     â”‚       â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                â”‚
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚    API GATEWAY        â”‚
                    â”‚   (FastAPI Backend)   â”‚
                    â””â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”˜
                        â”‚               â”‚
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”      â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚  AUTH SERVICE    â”‚      â”‚  STATS SERVICE    â”‚
        â”‚  - JWT Tokens    â”‚      â”‚  - Poisson        â”‚
        â”‚  - RLS Rules     â”‚      â”‚  - Dixon-Coles    â”‚
        â”‚  - Tier Check    â”‚      â”‚  - Elo Rating     â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â”‚  - Logistic Reg   â”‚
                                  â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                       â”‚
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚         ML PREDICTION ENGINE                 â”‚
        â”‚         (Admin Only)                         â”‚
        â”‚  - RandomForest  - XGBoost                  â”‚
        â”‚  - Feature Engineering                       â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                           â”‚
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚         SUPABASE (PostgreSQL)               â”‚
    â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
    â”‚  â”‚ Fixtures â”‚  â”‚ Teams    â”‚  â”‚ Users    â”‚ â”‚
    â”‚  â”‚ Stats    â”‚  â”‚ Leagues  â”‚  â”‚ Subs     â”‚ â”‚
    â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                       â”‚
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚       API-FOOTBALL SERVICE                   â”‚
    â”‚  - Historical Data Sync (Daily)             â”‚
    â”‚  - Fixtures Update (Hourly)                 â”‚
    â”‚  - Live Stats Polling (1-second)            â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

KEY ARCHITECTURE PRINCIPLES:
âœ“ Microservices-ready design
âœ“ Horizontal scalability
âœ“ Real-time data synchronization
âœ“ Caching at multiple layers
âœ“ Rate limiting for external APIs
âœ“ Security-first (RLS, JWT, HTTPS)


1.2 TECHNOLOGY STACK
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

BACKEND:
  â”œâ”€â”€ FastAPI 0.109+              (High-performance async API framework)
  â”œâ”€â”€ SQLAlchemy 2.0+             (ORM with async support)
  â”œâ”€â”€ Pydantic 2.0+               (Data validation)
  â”œâ”€â”€ uvicorn                     (ASGI server)
  â”œâ”€â”€ python-jose[cryptography]   (JWT tokens)
  â”œâ”€â”€ passlib[bcrypt]             (Password hashing)
  â””â”€â”€ httpx                       (Async HTTP client for API-Football)

DATABASE:
  â”œâ”€â”€ Supabase (Managed PostgreSQL 15+)
  â”œâ”€â”€ PostGIS extension           (Geospatial data if needed)
  â”œâ”€â”€ pg_cron                     (Scheduled jobs)
  â””â”€â”€ Realtime (WebSocket subscriptions)

STATISTICAL MODELS:
  â”œâ”€â”€ NumPy 1.24+                 (Numerical computations)
  â”œâ”€â”€ SciPy 1.10+                 (Statistical functions)
  â”œâ”€â”€ Pandas 2.0+                 (Data manipulation)
  â””â”€â”€ Statsmodels 0.14+           (Statistical models)

MACHINE LEARNING (ADMIN):
  â”œâ”€â”€ Scikit-learn 1.3+           (RandomForest, preprocessing)
  â”œâ”€â”€ XGBoost 2.0+                (Gradient boosting)
  â”œâ”€â”€ Joblib                      (Model serialization)
  â””â”€â”€ MLflow (optional)           (Model tracking)

FRONTEND:
  â”œâ”€â”€ React 18+                   (UI framework)
  â”œâ”€â”€ Vite 5+                     (Build tool)
  â”œâ”€â”€ TypeScript 5+               (Type safety)
  â”œâ”€â”€ Tailwind CSS 3+             (Styling)
  â”œâ”€â”€ React Query (TanStack)      (Data fetching)
  â”œâ”€â”€ Zustand                     (State management)
  â”œâ”€â”€ Recharts / Chart.js         (Data visualization)
  â””â”€â”€ Socket.io-client            (Real-time updates)

EXTERNAL APIS:
  â”œâ”€â”€ API-Football (RapidAPI)     (Football data source)
  â””â”€â”€ Stripe API                  (Payment processing)

DEPLOYMENT:
  â”œâ”€â”€ Docker 24+                  (Containerization)
  â”œâ”€â”€ Docker Compose              (Multi-container orchestration)
  â”œâ”€â”€ Nginx                       (Reverse proxy)
  â””â”€â”€ GreenGeeks Shared Hosting   (Production environment)

MONITORING:
  â”œâ”€â”€ Sentry                      (Error tracking)
  â”œâ”€â”€ Prometheus + Grafana        (Metrics - optional)
  â””â”€â”€ Supabase Dashboard          (Database monitoring)


1.3 DATABASE SCHEMA DESIGN
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

TABLE: users
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
id                  UUID PRIMARY KEY DEFAULT gen_random_uuid()
email               VARCHAR(255) UNIQUE NOT NULL
password_hash       VARCHAR(255) NOT NULL
full_name           VARCHAR(255)
tier                VARCHAR(20) DEFAULT 'free'
                    CHECK (tier IN ('free', 'starter', 'pro', 'premium', 'ultimate'))
subscription_id     VARCHAR(255)        -- Stripe subscription ID
subscription_status VARCHAR(20) DEFAULT 'active'
stripe_customer_id  VARCHAR(255)
created_at          TIMESTAMPTZ DEFAULT NOW()
updated_at          TIMESTAMPTZ DEFAULT NOW()
last_login          TIMESTAMPTZ

INDEXES:
  - idx_users_email ON users(email)
  - idx_users_tier ON users(tier)

RLS POLICIES:
  - Users can read their own data
  - Users can update their own profile (except tier)


TABLE: leagues
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
id                  INTEGER PRIMARY KEY      -- API-Football league ID
name                VARCHAR(255) NOT NULL
country             VARCHAR(100)
logo                TEXT
season              INTEGER NOT NULL
tier_required       VARCHAR(20) DEFAULT 'free'
                    CHECK (tier_required IN ('free', 'starter', 'pro', 'premium', 'ultimate'))
is_active           BOOLEAN DEFAULT true
priority            INTEGER DEFAULT 0        -- Display order
created_at          TIMESTAMPTZ DEFAULT NOW()
updated_at          TIMESTAMPTZ DEFAULT NOW()

INDEXES:
  - idx_leagues_tier ON leagues(tier_required)
  - idx_leagues_active ON leagues(is_active)

UNIQUE CONSTRAINT:
  - UNIQUE(id, season)


TABLE: teams
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
id                  INTEGER PRIMARY KEY      -- API-Football team ID
name                VARCHAR(255) NOT NULL
code                VARCHAR(10)
country             VARCHAR(100)
logo                TEXT
founded             INTEGER
venue_name          VARCHAR(255)
venue_capacity      INTEGER
created_at          TIMESTAMPTZ DEFAULT NOW()
updated_at          TIMESTAMPTZ DEFAULT NOW()

INDEXES:
  - idx_teams_name ON teams(name)


TABLE: fixtures
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
id                  INTEGER PRIMARY KEY      -- API-Football fixture ID
league_id           INTEGER REFERENCES leagues(id)
season              INTEGER NOT NULL
round               VARCHAR(50)
match_date          TIMESTAMPTZ NOT NULL
timestamp           BIGINT NOT NULL
home_team_id        INTEGER REFERENCES teams(id)
away_team_id        INTEGER REFERENCES teams(id)
status              VARCHAR(20)              -- 'NS', 'LIVE', 'FT', 'PST', etc.
elapsed_time        INTEGER                  -- Minutes played
venue               VARCHAR(255)
referee             VARCHAR(255)
created_at          TIMESTAMPTZ DEFAULT NOW()
updated_at          TIMESTAMPTZ DEFAULT NOW()

INDEXES:
  - idx_fixtures_league_season ON fixtures(league_id, season)
  - idx_fixtures_date ON fixtures(match_date)
  - idx_fixtures_status ON fixtures(status)
  - idx_fixtures_teams ON fixtures(home_team_id, away_team_id)
  - idx_fixtures_round ON fixtures(round)

UNIQUE CONSTRAINT:
  - UNIQUE(id)


TABLE: fixture_stats
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
id                  UUID PRIMARY KEY DEFAULT gen_random_uuid()
fixture_id          INTEGER REFERENCES fixtures(id)
team_id             INTEGER REFERENCES teams(id)
shots_on_goal       INTEGER
shots_off_goal      INTEGER
total_shots         INTEGER
blocked_shots       INTEGER
shots_inside_box    INTEGER
shots_outside_box   INTEGER
fouls               INTEGER
corners             INTEGER
offsides            INTEGER
ball_possession     INTEGER              -- Percentage
yellow_cards        INTEGER
red_cards           INTEGER
goalkeeper_saves    INTEGER
total_passes        INTEGER
passes_accurate     INTEGER
passes_percentage   INTEGER
expected_goals      DECIMAL(5,2)         -- xG
created_at          TIMESTAMPTZ DEFAULT NOW()
updated_at          TIMESTAMPTZ DEFAULT NOW()

INDEXES:
  - idx_fixture_stats_fixture ON fixture_stats(fixture_id)
  - idx_fixture_stats_team ON fixture_stats(team_id)

UNIQUE CONSTRAINT:
  - UNIQUE(fixture_id, team_id)


TABLE: fixture_scores
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
id                  UUID PRIMARY KEY DEFAULT gen_random_uuid()
fixture_id          INTEGER REFERENCES fixtures(id) UNIQUE
home_halftime       INTEGER
away_halftime       INTEGER
home_fulltime       INTEGER
away_fulltime       INTEGER
home_extratime      INTEGER
away_extratime      INTEGER
home_penalty        INTEGER
away_penalty        INTEGER
created_at          TIMESTAMPTZ DEFAULT NOW()
updated_at          TIMESTAMPTZ DEFAULT NOW()

INDEXES:
  - idx_fixture_scores_fixture ON fixture_scores(fixture_id)


TABLE: predictions
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
id                  UUID PRIMARY KEY DEFAULT gen_random_uuid()
fixture_id          INTEGER REFERENCES fixtures(id)
user_id             UUID REFERENCES users(id)
model_type          VARCHAR(50) NOT NULL     -- 'poisson', 'dixon_coles', 'elo', 'logistic', 'rf', 'xgboost'
prediction_data     JSONB NOT NULL           -- {home_win_prob, draw_prob, away_win_prob, score_prediction, etc.}
confidence_score    DECIMAL(5,2)
created_at          TIMESTAMPTZ DEFAULT NOW()
is_admin_model      BOOLEAN DEFAULT false    -- True for RF/XGBoost

INDEXES:
  - idx_predictions_fixture ON predictions(fixture_id)
  - idx_predictions_user ON predictions(user_id)
  - idx_predictions_model ON predictions(model_type)
  - idx_predictions_created ON predictions(created_at)

RLS POLICIES:
  - Users can see their own predictions
  - Users with appropriate tier can see model results
  - Admin can see all predictions


TABLE: team_ratings
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
id                  UUID PRIMARY KEY DEFAULT gen_random_uuid()
team_id             INTEGER REFERENCES teams(id)
league_id           INTEGER REFERENCES leagues(id)
season              INTEGER NOT NULL
elo_rating          DECIMAL(8,2) DEFAULT 1500
offensive_strength  DECIMAL(5,3)
defensive_strength  DECIMAL(5,3)
home_advantage      DECIMAL(5,3)
form_last_5         DECIMAL(3,2)         -- 0-5 scale
updated_at          TIMESTAMPTZ DEFAULT NOW()

INDEXES:
  - idx_team_ratings_team ON team_ratings(team_id)
  - idx_team_ratings_league_season ON team_ratings(league_id, season)

UNIQUE CONSTRAINT:
  - UNIQUE(team_id, league_id, season)


TABLE: user_settings
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
id                  UUID PRIMARY KEY DEFAULT gen_random_uuid()
user_id             UUID REFERENCES users(id) UNIQUE
favorite_leagues    INTEGER[]                -- Array of league IDs
favorite_teams      INTEGER[]                -- Array of team IDs
default_model       VARCHAR(50) DEFAULT 'poisson'
timezone            VARCHAR(50) DEFAULT 'UTC'
notifications       JSONB                    -- Notification preferences
ui_preferences      JSONB                    -- Dark mode, language, etc.
created_at          TIMESTAMPTZ DEFAULT NOW()
updated_at          TIMESTAMPTZ DEFAULT NOW()

INDEXES:
  - idx_user_settings_user ON user_settings(user_id)

RLS POLICIES:
  - Users can only access their own settings


TABLE: api_usage_logs
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
id                  UUID PRIMARY KEY DEFAULT gen_random_uuid()
api_name            VARCHAR(50) NOT NULL     -- 'api_football'
endpoint            VARCHAR(255)
response_status     INTEGER
response_time_ms    INTEGER
rate_limit_remaining INTEGER
error_message       TEXT
created_at          TIMESTAMPTZ DEFAULT NOW()

INDEXES:
  - idx_api_usage_created ON api_usage_logs(created_at)
  - idx_api_usage_api ON api_usage_logs(api_name)


TABLE: ml_model_versions
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
id                  UUID PRIMARY KEY DEFAULT gen_random_uuid()
model_name          VARCHAR(100) NOT NULL    -- 'random_forest_v1', 'xgboost_v2'
model_type          VARCHAR(50) NOT NULL     -- 'random_forest', 'xgboost'
version             VARCHAR(20) NOT NULL
model_path          TEXT                     -- S3/storage path
metrics             JSONB                    -- {accuracy, precision, recall, f1, etc.}
training_data_info  JSONB                    -- Training dataset details
is_active           BOOLEAN DEFAULT false
created_by          UUID REFERENCES users(id)
created_at          TIMESTAMPTZ DEFAULT NOW()

INDEXES:
  - idx_ml_models_name ON ml_model_versions(model_name)
  - idx_ml_models_active ON ml_model_versions(is_active)


1.4 API DESIGN
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

BASE URL: https://api.superstatsfootball.com/v1

AUTHENTICATION:
  All protected endpoints require JWT token in header:
  Authorization: Bearer <token>

PUBLIC ENDPOINTS:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

POST /auth/register
  Body: {email, password, full_name}
  Response: {user, access_token, refresh_token}

POST /auth/login
  Body: {email, password}
  Response: {user, access_token, refresh_token}

POST /auth/refresh
  Body: {refresh_token}
  Response: {access_token}

GET /leagues
  Query: ?tier=free&is_active=true
  Response: {leagues: [...]}

GET /fixtures/upcoming
  Query: ?league_id=39&next_round_only=true&limit=20
  Response: {fixtures: [...]}


PROTECTED ENDPOINTS (REQUIRE AUTH):
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

GET /user/profile
  Response: {user: {...}, subscription: {...}}

PUT /user/profile
  Body: {full_name, timezone, etc.}
  Response: {user: {...}}

GET /user/settings
  Response: {settings: {...}}

PUT /user/settings
  Body: {favorite_leagues, default_model, ui_preferences}
  Response: {settings: {...}}

GET /fixtures
  Query: ?league_id=39&season=2024&date_from=2024-01-01&date_to=2024-12-31
  Response: {fixtures: [...], pagination: {...}}

GET /fixtures/{fixture_id}
  Response: {fixture: {...}, stats: {...}, score: {...}}

GET /fixtures/{fixture_id}/stats
  Response: {home_stats: {...}, away_stats: {...}}

POST /predictions/calculate
  Body: {fixture_id, model_type: 'poisson'|'dixon_coles'|'elo'|'logistic'}
  Response: {prediction: {home_win_prob, draw_prob, away_win_prob, ...}}
  Note: Model availability depends on user tier

GET /predictions/{fixture_id}
  Response: {predictions: [...]}  # All predictions for this fixture

GET /teams/{team_id}
  Response: {team: {...}, ratings: {...}}

GET /teams/{team_id}/fixtures
  Query: ?season=2024&limit=10
  Response: {fixtures: [...]}


ADMIN ENDPOINTS (ADMIN ONLY):
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

GET /admin/debug
  Response: {system_stats, api_usage, db_health, cache_stats}

POST /admin/sync/historical
  Body: {league_id, season}
  Response: {status: 'started', job_id: '...'}

POST /admin/ml/train
  Body: {model_type: 'random_forest'|'xgboost', training_params: {...}}
  Response: {status: 'started', job_id: '...'}

GET /admin/ml/models
  Response: {models: [...]}

POST /admin/ml/predict
  Body: {fixture_id, model_version_id}
  Response: {prediction: {...}, confidence: ...}

GET /admin/users
  Query: ?tier=premium&limit=50&offset=0
  Response: {users: [...], pagination: {...}}

PUT /admin/users/{user_id}/tier
  Body: {tier: 'premium'}
  Response: {user: {...}}


WEBHOOK ENDPOINTS:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

POST /webhooks/stripe
  Body: Stripe event payload
  Response: {received: true}


REAL-TIME WEBSOCKET:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

WS /ws/fixtures/live
  Subscribe to live fixture updates
  Message format: {fixture_id, stats, score, elapsed_time, events}


1.5 TIERED ACCESS MODEL
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

TIER: FREE
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âœ“ Access to 2-3 major leagues (e.g., Premier League, La Liga)
âœ“ Basic statistics (fixtures, scores, basic team stats)
âœ“ Poisson model predictions only
âœ“ Next round fixtures only
âœ“ 50 API calls per day
âœ— No live stats
âœ— No historical data beyond current season
âœ— No advanced models
Price: $0/month

TIER: STARTER ($9.99/month)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âœ“ Everything in Free
âœ“ Access to 10 major leagues
âœ“ Poisson + Dixon-Coles models
âœ“ Live stats for selected matches
âœ“ Historical data (2 seasons back)
âœ“ 500 API calls per day
âœ“ Email notifications
âœ— No Elo or ML models

TIER: PRO ($19.99/month)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âœ“ Everything in Starter
âœ“ Access to 25 leagues worldwide
âœ“ Poisson + Dixon-Coles + Elo models
âœ“ Live stats for all matches
âœ“ Historical data (5 seasons back)
âœ“ 2000 API calls per day
âœ“ Advanced filtering and search
âœ“ Export data (CSV, JSON)
âœ— No ML admin models

TIER: PREMIUM ($39.99/month)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âœ“ Everything in Pro
âœ“ Access to 50+ leagues
âœ“ All statistical models (Poisson, DC, Elo, Logistic Regression)
âœ“ Historical data (10 seasons back)
âœ“ 5000 API calls per day
âœ“ Model comparison dashboard
âœ“ API access for personal use
âœ— No ML admin features

TIER: ULTIMATE ($99.99/month)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âœ“ Everything in Premium
âœ“ Access to ALL leagues (100+)
âœ“ ML models (RandomForest, XGBoost) - view only
âœ“ Admin debug panel - read access
âœ“ Complete historical data (all seasons available)
âœ“ Unlimited API calls
âœ“ Priority support
âœ“ Custom model training requests (quarterly)
âœ“ White-label options (additional fee)


LEAGUE COVERAGE BY TIER:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

FREE LEAGUES:
  - Premier League (England)
  - La Liga (Spain)
  - Bundesliga (Germany)

STARTER ADDS:
  - Serie A (Italy)
  - Ligue 1 (France)
  - Eredivisie (Netherlands)
  - Primeira Liga (Portugal)
  - Championship (England)
  - MLS (USA)
  - Liga MX (Mexico)

PRO ADDS:
  - All European top divisions
  - South American leagues (Brazil, Argentina)
  - Asian leagues (Japan, South Korea, Saudi Arabia)
  - Scottish Premiership
  - Turkish Super Lig
  - Belgian Pro League
  - Austrian Bundesliga
  - Swiss Super League
  - UEFA Champions League
  - UEFA Europa League
  - UEFA Conference League

PREMIUM ADDS:
  - All European second divisions
  - African leagues
  - Middle Eastern leagues
  - Australian A-League
  - More South American leagues
  - International competitions (World Cup, Euros, Copa America)

ULTIMATE:
  - ALL leagues supported by API-Football


PART 2: ENVIRONMENT SETUP

2.1 WINDOWS PREREQUISITES
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

STEP 1: Install Python 3.11+
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
1. Download Python from https://www.python.org/downloads/
2. During installation:
   âœ“ Check "Add Python to PATH"
   âœ“ Check "Install pip"
3. Verify installation:
   ```cmd
   python --version
   pip --version
   ```

STEP 2: Install Git
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
1. Download from https://git-scm.com/download/win
2. Install with default options
3. Verify:
   ```cmd
   git --version
   ```

STEP 3: Install Node.js 18+ (for frontend)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
1. Download from https://nodejs.org/
2. Install LTS version
3. Verify:
   ```cmd
   node --version
   npm --version
   ```

STEP 4: Install Visual Studio Code
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
1. Download from https://code.visualstudio.com/
2. Install recommended extensions:
   - Python
   - Pylance
   - Docker
   - ESLint
   - Prettier
   - Tailwind CSS IntelliSense


2.2 DOCKER DESKTOP INSTALLATION
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

STEP 1: System Requirements
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
- Windows 10 64-bit: Pro, Enterprise, or Education (Build 19041+)
- OR Windows 11
- WSL 2 enabled
- Virtualization enabled in BIOS

STEP 2: Enable WSL 2
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Open PowerShell as Administrator:
```powershell
wsl --install
wsl --set-default-version 2
```
Restart computer if prompted.

STEP 3: Install Docker Desktop
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
1. Download from https://www.docker.com/products/docker-desktop/
2. Run installer
3. During setup, ensure "Use WSL 2 instead of Hyper-V" is checked
4. Restart computer
5. Start Docker Desktop
6. Verify:
   ```cmd
   docker --version
   docker-compose --version
   ```

STEP 4: Configure Docker
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
1. Open Docker Desktop settings
2. Resources > Advanced:
   - CPUs: 4+
   - Memory: 8GB+
   - Swap: 2GB
3. Enable Docker Compose V2


2.3 DEVELOPMENT TOOLS SETUP
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

STEP 1: Create Project Directory
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
```cmd
mkdir C:\Projects\SuperStatsFootball
cd C:\Projects\SuperStatsFootball
```

STEP 2: Initialize Git Repository
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
```cmd
git init
git branch -M main
```

STEP 3: Create Python Virtual Environment
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
```cmd
python -m venv venv
venv\Scripts\activate
```

STEP 4: Create Project Structure
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
```cmd
mkdir backend
mkdir backend\app
mkdir backend\app\models
mkdir backend\app\routers
mkdir backend\app\services
mkdir backend\app\core
mkdir backend\app\ml
mkdir backend\tests
mkdir frontend
mkdir docker
mkdir scripts
```

STEP 5: Create .gitignore
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Create `.gitignore` in project root:
```
# Python
venv/
__pycache__/
*.py[cod]
*$py.class
*.so
.Python
env/
build/
dist/
*.egg-info/
.pytest_cache/
.coverage

# Environment
.env
.env.local
.env.*.local

# IDE
.vscode/
.idea/
*.swp
*.swo

# OS
.DS_Store
Thumbs.db

# Logs
*.log
logs/

# Database
*.db
*.sqlite

# ML Models
backend/app/ml/models/*.pkl
backend/app/ml/models/*.joblib

# Node
node_modules/
frontend/dist/
frontend/build/

# Docker
docker-compose.override.yml
```


2.4 SUPABASE ACCOUNT & PROJECT SETUP
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

STEP 1: Create Supabase Account
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
1. Go to https://supabase.com/
2. Sign up with GitHub or email
3. Verify email

STEP 2: Create New Project
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
1. Click "New Project"
2. Fill in:
   - Name: SuperStatsFootball
   - Database Password: (generate strong password)
   - Region: (choose closest to users)
   - Pricing Plan: Free tier (upgrade later)
3. Click "Create new project"
4. Wait 2-3 minutes for provisioning

STEP 3: Get API Credentials
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
1. Go to Project Settings > API
2. Copy the following:
   - Project URL (SUPABASE_URL)
   - Project API keys:
     - anon key (public) (SUPABASE_ANON_KEY)
     - service_role key (private) (SUPABASE_SERVICE_KEY)

STEP 4: Configure Database
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
1. Go to Database > Settings
2. Enable these extensions (if not already enabled):
   - pg_cron
   - pgcrypto
   - pgjwt
3. Connection string:
   - Go to Database > Settings > Connection string
   - Copy Direct connection string

STEP 5: Enable Realtime
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
1. Go to Database > Replication
2. Enable replication for tables (will do after creating tables):
   - fixtures
   - fixture_stats
   - fixture_scores

STEP 6: Create Environment File
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Create `backend/.env`:
```env
# Database
SUPABASE_URL=https://your-project.supabase.co
SUPABASE_ANON_KEY=your-anon-key
SUPABASE_SERVICE_KEY=your-service-role-key
DATABASE_URL=postgresql://postgres:[YOUR-PASSWORD]@db.your-project.supabase.co:5432/postgres

# API-Football (will get in next section)
APIFOOTBALL_API_KEY=your-api-key-here
APIFOOTBALL_BASE_URL=https://v3.football.api-sports.io

# JWT Secret (generate: openssl rand -hex 32)
SECRET_KEY=your-secret-key-here
ALGORITHM=HS256
ACCESS_TOKEN_EXPIRE_MINUTES=30
REFRESH_TOKEN_EXPIRE_DAYS=7

# Stripe (will configure later)
STRIPE_SECRET_KEY=sk_test_...
STRIPE_WEBHOOK_SECRET=whsec_...
STRIPE_PRICE_ID_STARTER=price_...
STRIPE_PRICE_ID_PRO=price_...
STRIPE_PRICE_ID_PREMIUM=price_...
STRIPE_PRICE_ID_ULTIMATE=price_...

# Environment
ENVIRONMENT=development
DEBUG=True
BACKEND_CORS_ORIGINS=["http://localhost:5173"]

# Redis (for caching - will setup later)
REDIS_URL=redis://localhost:6379/0

# Sentry (for error tracking - optional)
SENTRY_DSN=
```


PART 3: BACKEND DEVELOPMENT (FASTAPI)

3.1 PROJECT STRUCTURE
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

backend/
â”œâ”€â”€ app/
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ main.py                  # FastAPI application entry point
â”‚   â”œâ”€â”€ core/
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ config.py            # Configuration settings
â”‚   â”‚   â”œâ”€â”€ security.py          # JWT, password hashing
â”‚   â”‚   â”œâ”€â”€ dependencies.py      # Dependency injection
â”‚   â”‚   â””â”€â”€ exceptions.py        # Custom exceptions
â”‚   â”œâ”€â”€ models/
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ user.py              # User SQLAlchemy model
â”‚   â”‚   â”œâ”€â”€ league.py            # League model
â”‚   â”‚   â”œâ”€â”€ team.py              # Team model
â”‚   â”‚   â”œâ”€â”€ fixture.py           # Fixture, stats, scores models
â”‚   â”‚   â”œâ”€â”€ prediction.py        # Prediction model
â”‚   â”‚   â””â”€â”€ settings.py          # User settings model
â”‚   â”œâ”€â”€ schemas/
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ user.py              # User Pydantic schemas
â”‚   â”‚   â”œâ”€â”€ league.py            # League schemas
â”‚   â”‚   â”œâ”€â”€ team.py              # Team schemas
â”‚   â”‚   â”œâ”€â”€ fixture.py           # Fixture schemas
â”‚   â”‚   â””â”€â”€ prediction.py        # Prediction schemas
â”‚   â”œâ”€â”€ routers/
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ auth.py              # Authentication endpoints
â”‚   â”‚   â”œâ”€â”€ users.py             # User management
â”‚   â”‚   â”œâ”€â”€ leagues.py           # League endpoints
â”‚   â”‚   â”œâ”€â”€ fixtures.py          # Fixture endpoints
â”‚   â”‚   â”œâ”€â”€ predictions.py       # Prediction endpoints
â”‚   â”‚   â”œâ”€â”€ admin.py             # Admin endpoints
â”‚   â”‚   â””â”€â”€ webhooks.py          # Stripe webhooks
â”‚   â”œâ”€â”€ services/
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ auth_service.py      # Authentication logic
â”‚   â”‚   â”œâ”€â”€ apifootball.py       # API-Football client
â”‚   â”‚   â”œâ”€â”€ cache.py             # Redis caching
â”‚   â”‚   â”œâ”€â”€ subscription.py      # Stripe subscription management
â”‚   â”‚   â””â”€â”€ websocket.py         # WebSocket manager
â”‚   â”œâ”€â”€ ml/
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ models/              # Trained model files (.pkl)
â”‚   â”‚   â”œâ”€â”€ statistical/
â”‚   â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”‚   â”œâ”€â”€ poisson.py       # Poisson model
â”‚   â”‚   â”‚   â”œâ”€â”€ dixon_coles.py   # Dixon-Coles model
â”‚   â”‚   â”‚   â”œâ”€â”€ elo.py           # Elo rating system
â”‚   â”‚   â”‚   â””â”€â”€ logistic.py      # Logistic regression
â”‚   â”‚   â”œâ”€â”€ machine_learning/
â”‚   â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”‚   â”œâ”€â”€ feature_engineering.py
â”‚   â”‚   â”‚   â”œâ”€â”€ random_forest.py
â”‚   â”‚   â”‚   â””â”€â”€ xgboost_model.py
â”‚   â”‚   â””â”€â”€ model_manager.py     # Model loading/versioning
â”‚   â”œâ”€â”€ db/
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ session.py           # Database session management
â”‚   â”‚   â”œâ”€â”€ base.py              # Base model class
â”‚   â”‚   â””â”€â”€ init_db.py           # Database initialization
â”‚   â””â”€â”€ utils/
â”‚       â”œâ”€â”€ __init__.py
â”‚       â”œâ”€â”€ logger.py            # Logging configuration
â”‚       â””â”€â”€ validators.py        # Custom validators
â”œâ”€â”€ tests/
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ conftest.py
â”‚   â”œâ”€â”€ test_auth.py
â”‚   â”œâ”€â”€ test_fixtures.py
â”‚   â””â”€â”€ test_predictions.py
â”œâ”€â”€ alembic/                     # Database migrations
â”‚   â”œâ”€â”€ versions/
â”‚   â””â”€â”€ env.py
â”œâ”€â”€ requirements.txt
â”œâ”€â”€ Dockerfile
â””â”€â”€ .env


3.2 FASTAPI APPLICATION SETUP
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

FILE: backend/requirements.txt
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
```txt
# FastAPI
fastapi==0.109.0
uvicorn[standard]==0.27.0
python-multipart==0.0.6

# Database
sqlalchemy==2.0.25
alembic==1.13.1
psycopg2-binary==2.9.9
asyncpg==0.29.0

# Supabase
supabase==2.3.4

# Authentication
python-jose[cryptography]==3.3.0
passlib[bcrypt]==1.7.4
python-dotenv==1.0.0

# HTTP Client
httpx==0.26.0

# Data Processing
pandas==2.2.0
numpy==1.26.3

# Statistical Models
scipy==1.12.0
statsmodels==0.14.1

# Machine Learning
scikit-learn==1.4.0
xgboost==2.0.3
joblib==1.3.2

# Caching
redis==5.0.1
hiredis==2.3.2

# Payment
stripe==7.11.0

# WebSocket
python-socketio==5.11.0
python-socketio[asyncio_client]

# Monitoring
sentry-sdk[fastapi]==1.40.0

# Testing
pytest==7.4.4
pytest-asyncio==0.23.3
httpx==0.26.0

# Utilities
pydantic==2.5.3
pydantic-settings==2.1.0
```

Install dependencies:
```cmd
cd backend
pip install -r requirements.txt
```


FILE: backend/app/core/config.py
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
```python
from pydantic_settings import BaseSettings, SettingsConfigDict
from typing import List
import secrets


class Settings(BaseSettings):
    model_config = SettingsConfigDict(
        env_file=".env",
        env_file_encoding="utf-8",
        case_sensitive=True
    )

    # Application
    APP_NAME: str = "SuperStatsFootball"
    VERSION: str = "1.0.0"
    ENVIRONMENT: str = "development"
    DEBUG: bool = True
    API_V1_PREFIX: str = "/api/v1"

    # Database
    DATABASE_URL: str
    SUPABASE_URL: str
    SUPABASE_ANON_KEY: str
    SUPABASE_SERVICE_KEY: str

    # Security
    SECRET_KEY: str = secrets.token_urlsafe(32)
    ALGORITHM: str = "HS256"
    ACCESS_TOKEN_EXPIRE_MINUTES: int = 30
    REFRESH_TOKEN_EXPIRE_DAYS: int = 7

    # CORS
    BACKEND_CORS_ORIGINS: List[str] = [
        "http://localhost:5173",
        "http://localhost:3000"
    ]

    # API-Football
    APIFOOTBALL_API_KEY: str
    APIFOOTBALL_BASE_URL: str = "https://v3.football.api-sports.io"
    APIFOOTBALL_RATE_LIMIT: int = 100  # requests per day for free tier

    # Stripe
    STRIPE_SECRET_KEY: str = ""
    STRIPE_WEBHOOK_SECRET: str = ""
    STRIPE_PRICE_ID_STARTER: str = ""
    STRIPE_PRICE_ID_PRO: str = ""
    STRIPE_PRICE_ID_PREMIUM: str = ""
    STRIPE_PRICE_ID_ULTIMATE: str = ""

    # Redis
    REDIS_URL: str = "redis://localhost:6379/0"
    CACHE_TTL: int = 300  # 5 minutes

    # Sentry
    SENTRY_DSN: str = ""

    # Tiers
    TIER_HIERARCHY: dict = {
        "free": 0,
        "starter": 1,
        "pro": 2,
        "premium": 3,
        "ultimate": 4
    }

    TIER_MODELS: dict = {
        "free": ["poisson"],
        "starter": ["poisson", "dixon_coles"],
        "pro": ["poisson", "dixon_coles", "elo"],
        "premium": ["poisson", "dixon_coles", "elo", "logistic"],
        "ultimate": ["poisson", "dixon_coles", "elo", "logistic", "random_forest", "xgboost"]
    }

    # ML Models
    ML_MODEL_PATH: str = "app/ml/models"

    class Config:
        case_sensitive = True


settings = Settings()
```


FILE: backend/app/core/security.py
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
```python
from datetime import datetime, timedelta
from typing import Optional, Dict, Any
from jose import JWTError, jwt
from passlib.context import CryptContext
from fastapi import HTTPException, status
from .config import settings

pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")


def verify_password(plain_password: str, hashed_password: str) -> bool:
    """Verify a password against a hash."""
    return pwd_context.verify(plain_password, hashed_password)


def get_password_hash(password: str) -> str:
    """Hash a password."""
    return pwd_context.hash(password)


def create_access_token(data: Dict[str, Any], expires_delta: Optional[timedelta] = None) -> str:
    """Create a JWT access token."""
    to_encode = data.copy()

    if expires_delta:
        expire = datetime.utcnow() + expires_delta
    else:
        expire = datetime.utcnow() + timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES)

    to_encode.update({"exp": expire, "type": "access"})
    encoded_jwt = jwt.encode(to_encode, settings.SECRET_KEY, algorithm=settings.ALGORITHM)
    return encoded_jwt


def create_refresh_token(data: Dict[str, Any]) -> str:
    """Create a JWT refresh token."""
    to_encode = data.copy()
    expire = datetime.utcnow() + timedelta(days=settings.REFRESH_TOKEN_EXPIRE_DAYS)
    to_encode.update({"exp": expire, "type": "refresh"})
    encoded_jwt = jwt.encode(to_encode, settings.SECRET_KEY, algorithm=settings.ALGORITHM)
    return encoded_jwt


def verify_token(token: str, token_type: str = "access") -> Dict[str, Any]:
    """Verify and decode a JWT token."""
    try:
        payload = jwt.decode(token, settings.SECRET_KEY, algorithms=[settings.ALGORITHM])

        if payload.get("type") != token_type:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail=f"Invalid token type. Expected {token_type}"
            )

        return payload

    except JWTError:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Could not validate credentials",
            headers={"WWW-Authenticate": "Bearer"}
        )


def check_tier_access(user_tier: str, required_tier: str) -> bool:
    """Check if user's tier meets the required tier."""
    user_level = settings.TIER_HIERARCHY.get(user_tier, 0)
    required_level = settings.TIER_HIERARCHY.get(required_tier, 0)
    return user_level >= required_level


def check_model_access(user_tier: str, model_type: str) -> bool:
    """Check if user's tier has access to the specified model."""
    allowed_models = settings.TIER_MODELS.get(user_tier, [])
    return model_type in allowed_models
```


FILE: backend/app/db/session.py
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
```python
from sqlalchemy import create_engine
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker
from ..core.config import settings

# Create SQLAlchemy engine
engine = create_engine(
    settings.DATABASE_URL,
    pool_pre_ping=True,
    pool_size=10,
    max_overflow=20
)

# Create SessionLocal class
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

# Base class for models
Base = declarative_base()


def get_db():
    """Dependency for getting database session."""
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()
```


FILE: backend/app/main.py
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
```python
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import JSONResponse
import sentry_sdk
from sentry_sdk.integrations.fastapi import FastApiIntegration
from sentry_sdk.integrations.sqlalchemy import SqlalchemyIntegration

from app.core.config import settings
from app.routers import auth, users, leagues, fixtures, predictions, admin, webhooks
from app.db.session import engine
from app.db.base import Base

# Initialize Sentry (if configured)
if settings.SENTRY_DSN:
    sentry_sdk.init(
        dsn=settings.SENTRY_DSN,
        integrations=[
            FastApiIntegration(),
            SqlalchemyIntegration()
        ],
        traces_sample_rate=1.0 if settings.ENVIRONMENT == "development" else 0.1,
        environment=settings.ENVIRONMENT
    )

# Create FastAPI app
app = FastAPI(
    title=settings.APP_NAME,
    version=settings.VERSION,
    description="High-performance football statistics and prediction API",
    debug=settings.DEBUG
)

# CORS middleware
app.add_middleware(
    CORSMiddleware,
    allow_origins=settings.BACKEND_CORS_ORIGINS,
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"]
)

# Include routers
app.include_router(auth.router, prefix=f"{settings.API_V1_PREFIX}/auth", tags=["Authentication"])
app.include_router(users.router, prefix=f"{settings.API_V1_PREFIX}/users", tags=["Users"])
app.include_router(leagues.router, prefix=f"{settings.API_V1_PREFIX}/leagues", tags=["Leagues"])
app.include_router(fixtures.router, prefix=f"{settings.API_V1_PREFIX}/fixtures", tags=["Fixtures"])
app.include_router(predictions.router, prefix=f"{settings.API_V1_PREFIX}/predictions", tags=["Predictions"])
app.include_router(admin.router, prefix=f"{settings.API_V1_PREFIX}/admin", tags=["Admin"])
app.include_router(webhooks.router, prefix=f"{settings.API_V1_PREFIX}/webhooks", tags=["Webhooks"])


@app.on_event("startup")
async def startup_event():
    """Run on application startup."""
    print(f"ğŸš€ {settings.APP_NAME} v{settings.VERSION} starting...")
    print(f"ğŸ“ Environment: {settings.ENVIRONMENT}")
    print(f"ğŸ”’ Debug mode: {settings.DEBUG}")

    # Create database tables (in production, use Alembic migrations)
    if settings.ENVIRONMENT == "development":
        Base.metadata.create_all(bind=engine)


@app.on_event("shutdown")
async def shutdown_event():
    """Run on application shutdown."""
    print(f"ğŸ‘‹ {settings.APP_NAME} shutting down...")


@app.get("/")
async def root():
    """Root endpoint."""
    return {
        "message": f"Welcome to {settings.APP_NAME} API",
        "version": settings.VERSION,
        "docs": "/docs"
    }


@app.get("/health")
async def health_check():
    """Health check endpoint."""
    return {
        "status": "healthy",
        "environment": settings.ENVIRONMENT,
        "version": settings.VERSION
    }


@app.exception_handler(Exception)
async def global_exception_handler(request, exc):
    """Global exception handler."""
    if settings.DEBUG:
        raise exc

    return JSONResponse(
        status_code=500,
        content={
            "detail": "Internal server error",
            "message": str(exc) if settings.DEBUG else "An error occurred"
        }
    )
```


3.3 DATABASE MODELS & ORM (SQLALCHEMY)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

FILE: backend/app/db/base.py
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
```python
from sqlalchemy.ext.declarative import as_declarative, declared_attr
from datetime import datetime


@as_declarative()
class Base:
    id: any
    __name__: str

    # Generate __tablename__ automatically
    @declared_attr
    def __tablename__(cls) -> str:
        return cls.__name__.lower()
```


FILE: backend/app/models/user.py
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
```python
from sqlalchemy import Column, String, DateTime, Enum
from sqlalchemy.dialects.postgresql import UUID
from datetime import datetime
import uuid
import enum

from app.db.base import Base


class TierEnum(str, enum.Enum):
    FREE = "free"
    STARTER = "starter"
    PRO = "pro"
    PREMIUM = "premium"
    ULTIMATE = "ultimate"


class User(Base):
    __tablename__ = "users"

    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    email = Column(String(255), unique=True, nullable=False, index=True)
    password_hash = Column(String(255), nullable=False)
    full_name = Column(String(255))
    tier = Column(Enum(TierEnum), default=TierEnum.FREE, nullable=False, index=True)
    subscription_id = Column(String(255))
    subscription_status = Column(String(20), default="active")
    stripe_customer_id = Column(String(255))
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    last_login = Column(DateTime)

    def __repr__(self):
        return f"<User {self.email}>"
```


FILE: backend/app/models/league.py
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
```python
from sqlalchemy import Column, Integer, String, Boolean, DateTime
from datetime import datetime

from app.db.base import Base


class League(Base):
    __tablename__ = "leagues"

    id = Column(Integer, primary_key=True)  # API-Football league ID
    name = Column(String(255), nullable=False)
    country = Column(String(100))
    logo = Column(String)
    season = Column(Integer, nullable=False)
    tier_required = Column(String(20), default="free", index=True)
    is_active = Column(Boolean, default=True, index=True)
    priority = Column(Integer, default=0)
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)

    def __repr__(self):
        return f"<League {self.name} ({self.season})>"
```


FILE: backend/app/models/team.py
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
```python
from sqlalchemy import Column, Integer, String, DateTime
from datetime import datetime

from app.db.base import Base


class Team(Base):
    __tablename__ = "teams"

    id = Column(Integer, primary_key=True)  # API-Football team ID
    name = Column(String(255), nullable=False, index=True)
    code = Column(String(10))
    country = Column(String(100))
    logo = Column(String)
    founded = Column(Integer)
    venue_name = Column(String(255))
    venue_capacity = Column(Integer)
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)

    def __repr__(self):
        return f"<Team {self.name}>"
```


FILE: backend/app/models/fixture.py
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
```python
from sqlalchemy import Column, Integer, String, DateTime, BigInteger, ForeignKey, DECIMAL
from sqlalchemy.dialects.postgresql import UUID, JSONB
from sqlalchemy.orm import relationship
from datetime import datetime
import uuid

from app.db.base import Base


class Fixture(Base):
    __tablename__ = "fixtures"

    id = Column(Integer, primary_key=True)  # API-Football fixture ID
    league_id = Column(Integer, ForeignKey("leagues.id"), index=True)
    season = Column(Integer, nullable=False)
    round = Column(String(50), index=True)
    match_date = Column(DateTime, nullable=False, index=True)
    timestamp = Column(BigInteger, nullable=False)
    home_team_id = Column(Integer, ForeignKey("teams.id"), index=True)
    away_team_id = Column(Integer, ForeignKey("teams.id"), index=True)
    status = Column(String(20), index=True)  # 'NS', 'LIVE', 'FT', etc.
    elapsed_time = Column(Integer)
    venue = Column(String(255))
    referee = Column(String(255))
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)

    # Relationships
    league = relationship("League", backref="fixtures")
    home_team = relationship("Team", foreign_keys=[home_team_id], backref="home_fixtures")
    away_team = relationship("Team", foreign_keys=[away_team_id], backref="away_fixtures")

    def __repr__(self):
        return f"<Fixture {self.id}: {self.home_team_id} vs {self.away_team_id}>"


class FixtureStat(Base):
    __tablename__ = "fixture_stats"

    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    fixture_id = Column(Integer, ForeignKey("fixtures.id"), nullable=False, index=True)
    team_id = Column(Integer, ForeignKey("teams.id"), nullable=False, index=True)
    shots_on_goal = Column(Integer)
    shots_off_goal = Column(Integer)
    total_shots = Column(Integer)
    blocked_shots = Column(Integer)
    shots_inside_box = Column(Integer)
    shots_outside_box = Column(Integer)
    fouls = Column(Integer)
    corners = Column(Integer)
    offsides = Column(Integer)
    ball_possession = Column(Integer)
    yellow_cards = Column(Integer)
    red_cards = Column(Integer)
    goalkeeper_saves = Column(Integer)
    total_passes = Column(Integer)
    passes_accurate = Column(Integer)
    passes_percentage = Column(Integer)
    expected_goals = Column(DECIMAL(5, 2))
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)

    # Relationships
    fixture = relationship("Fixture", backref="stats")
    team = relationship("Team", backref="fixture_stats")


class FixtureScore(Base):
    __tablename__ = "fixture_scores"

    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    fixture_id = Column(Integer, ForeignKey("fixtures.id"), nullable=False, unique=True, index=True)
    home_halftime = Column(Integer)
    away_halftime = Column(Integer)
    home_fulltime = Column(Integer)
    away_fulltime = Column(Integer)
    home_extratime = Column(Integer)
    away_extratime = Column(Integer)
    home_penalty = Column(Integer)
    away_penalty = Column(Integer)
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)

    # Relationships
    fixture = relationship("Fixture", backref="score", uselist=False)
```


PART 4: APIFOOTBALL INTEGRATION

4.1 API-FOOTBALL ACCOUNT SETUP
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

STEP 1: Create RapidAPI Account
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
1. Go to https://rapidapi.com/
2. Sign up with email or GitHub
3. Verify email

STEP 2: Subscribe to API-Football
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
1. Go to https://rapidapi.com/api-sports/api/api-football
2. Click "Subscribe to Test"
3. Choose a plan:
   - FREE: 100 requests/day (testing only)
   - BASIC: $10/month - 3,000 requests/day
   - PRO: $30/month - 10,000 requests/day
   - ULTRA: $80/month - 30,000 requests/day

   Recommendation: Start with BASIC, upgrade as needed

STEP 3: Get API Key
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
1. Go to your RapidAPI dashboard
2. Find "API-Football" in your subscriptions
3. Copy your API key (X-RapidAPI-Key)
4. Add to backend/.env:
   ```
   APIFOOTBALL_API_KEY=your-api-key-here
   ```

STEP 4: Test API Connection
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
```bash
curl --request GET \
     --url 'https://v3.football.api-sports.io/status' \
     --header 'x-rapidapi-host: v3.football.api-sports.io' \
     --header 'x-rapidapi-key: YOUR-API-KEY'
```


4.2 HISTORICAL DATA INGESTION
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

FILE: backend/app/services/apifootball.py
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
```python
import httpx
from typing import Dict, List, Optional, Any
from datetime import datetime, date
import asyncio
from app.core.config import settings
from app.utils.logger import logger


class APIFootballClient:
    """Client for API-Football API."""

    def __init__(self):
        self.base_url = settings.APIFOOTBALL_BASE_URL
        self.api_key = settings.APIFOOTBALL_API_KEY
        self.headers = {
            "x-rapidapi-host": "v3.football.api-sports.io",
            "x-rapidapi-key": self.api_key
        }
        self.client = httpx.AsyncClient(headers=self.headers, timeout=30.0)

    async def _make_request(self, endpoint: str, params: Optional[Dict] = None) -> Dict[str, Any]:
        """Make an API request with rate limiting and error handling."""
        url = f"{self.base_url}/{endpoint}"

        try:
            response = await self.client.get(url, params=params)
            response.raise_for_status()

            data = response.json()

            # Log API usage
            logger.info(f"API-Football request: {endpoint} - {response.status_code}")
            logger.info(f"Rate limit: {response.headers.get('x-ratelimit-remaining', 'N/A')}/{response.headers.get('x-ratelimit-limit', 'N/A')}")

            if data.get("errors"):
                logger.error(f"API-Football error: {data['errors']}")
                raise Exception(f"API error: {data['errors']}")

            return data

        except httpx.HTTPError as e:
            logger.error(f"HTTP error during API request: {str(e)}")
            raise
        except Exception as e:
            logger.error(f"Error during API request: {str(e)}")
            raise

    async def get_leagues(self, season: Optional[int] = None, country: Optional[str] = None) -> List[Dict]:
        """Get leagues."""
        params = {}
        if season:
            params["season"] = season
        if country:
            params["country"] = country

        data = await self._make_request("leagues", params)
        return data.get("response", [])

    async def get_teams(self, league_id: int, season: int) -> List[Dict]:
        """Get teams in a league for a season."""
        params = {
            "league": league_id,
            "season": season
        }

        data = await self._make_request("teams", params)
        return data.get("response", [])

    async def get_fixtures(
        self,
        league_id: Optional[int] = None,
        season: Optional[int] = None,
        date_from: Optional[str] = None,
        date_to: Optional[str] = None,
        team_id: Optional[int] = None,
        fixture_id: Optional[int] = None,
        status: Optional[str] = None
    ) -> List[Dict]:
        """Get fixtures."""
        params = {}

        if fixture_id:
            params["id"] = fixture_id
        if league_id:
            params["league"] = league_id
        if season:
            params["season"] = season
        if date_from:
            params["from"] = date_from
        if date_to:
            params["to"] = date_to
        if team_id:
            params["team"] = team_id
        if status:
            params["status"] = status

        data = await self._make_request("fixtures", params)
        return data.get("response", [])

    async def get_fixture_statistics(self, fixture_id: int) -> List[Dict]:
        """Get statistics for a fixture."""
        params = {"fixture": fixture_id}
        data = await self._make_request("fixtures/statistics", params)
        return data.get("response", [])

    async def get_fixture_events(self, fixture_id: int) -> List[Dict]:
        """Get events (goals, cards, etc.) for a fixture."""
        params = {"fixture": fixture_id}
        data = await self._make_request("fixtures/events", params)
        return data.get("response", [])

    async def get_standings(self, league_id: int, season: int) -> List[Dict]:
        """Get league standings."""
        params = {
            "league": league_id,
            "season": season
        }
        data = await self._make_request("standings", params)
        return data.get("response", [])

    async def close(self):
        """Close the HTTP client."""
        await self.client.aclose()


# Global client instance
api_football_client = APIFootballClient()
```


FILE: backend/scripts/sync_historical_data.py
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
```python
"""
Script to sync historical football data from API-Football.
Run: python -m backend.scripts.sync_historical_data --league 39 --season 2023
"""

import asyncio
import argparse
from datetime import datetime
from sqlalchemy.orm import Session

from app.db.session import SessionLocal
from app.services.apifootball import api_football_client
from app.models.league import League
from app.models.team import Team
from app.models.fixture import Fixture, FixtureStat, FixtureScore
from app.utils.logger import logger


async def sync_league(db: Session, league_id: int, season: int):
    """Sync league data."""
    logger.info(f"Syncing league {league_id} for season {season}...")

    # Get league info
    leagues_data = await api_football_client.get_leagues(season=season)
    league_data = next((l for l in leagues_data if l["league"]["id"] == league_id), None)

    if not league_data:
        logger.error(f"League {league_id} not found for season {season}")
        return

    # Upsert league
    league = db.query(League).filter_by(id=league_id, season=season).first()

    if not league:
        league = League(
            id=league_data["league"]["id"],
            name=league_data["league"]["name"],
            country=league_data["country"]["name"],
            logo=league_data["league"]["logo"],
            season=season,
            tier_required="free",  # Configure as needed
            is_active=True
        )
        db.add(league)
    else:
        league.name = league_data["league"]["name"]
        league.country = league_data["country"]["name"]
        league.logo = league_data["league"]["logo"]
        league.updated_at = datetime.utcnow()

    db.commit()
    logger.info(f"League synced: {league.name}")


async def sync_teams(db: Session, league_id: int, season: int):
    """Sync teams in a league."""
    logger.info(f"Syncing teams for league {league_id}, season {season}...")

    teams_data = await api_football_client.get_teams(league_id, season)

    for team_data in teams_data:
        team_info = team_data["team"]
        venue_info = team_data["venue"]

        team = db.query(Team).filter_by(id=team_info["id"]).first()

        if not team:
            team = Team(
                id=team_info["id"],
                name=team_info["name"],
                code=team_info["code"],
                country=team_info["country"],
                logo=team_info["logo"],
                founded=team_info["founded"],
                venue_name=venue_info["name"],
                venue_capacity=venue_info["capacity"]
            )
            db.add(team)
        else:
            team.name = team_info["name"]
            team.code = team_info["code"]
            team.logo = team_info["logo"]
            team.venue_name = venue_info["name"]
            team.venue_capacity = venue_info["capacity"]
            team.updated_at = datetime.utcnow()

    db.commit()
    logger.info(f"Synced {len(teams_data)} teams")


async def sync_fixtures(db: Session, league_id: int, season: int):
    """Sync fixtures for a league season."""
    logger.info(f"Syncing fixtures for league {league_id}, season {season}...")

    fixtures_data = await api_football_client.get_fixtures(league_id=league_id, season=season)

    for fixture_data in fixtures_data:
        fixture_info = fixture_data["fixture"]
        league_info = fixture_data["league"]
        teams_info = fixture_data["teams"]
        goals_info = fixture_data["goals"]
        score_info = fixture_data["score"]

        # Upsert fixture
        fixture = db.query(Fixture).filter_by(id=fixture_info["id"]).first()

        if not fixture:
            fixture = Fixture(
                id=fixture_info["id"],
                league_id=league_info["id"],
                season=league_info["season"],
                round=league_info["round"],
                match_date=datetime.fromisoformat(fixture_info["date"].replace("Z", "+00:00")),
                timestamp=fixture_info["timestamp"],
                home_team_id=teams_info["home"]["id"],
                away_team_id=teams_info["away"]["id"],
                status=fixture_info["status"]["short"],
                elapsed_time=fixture_info["status"]["elapsed"],
                venue=fixture_info["venue"]["name"],
                referee=fixture_info["referee"]
            )
            db.add(fixture)
        else:
            fixture.status = fixture_info["status"]["short"]
            fixture.elapsed_time = fixture_info["status"]["elapsed"]
            fixture.updated_at = datetime.utcnow()

        db.commit()

        # Sync score
        score = db.query(FixtureScore).filter_by(fixture_id=fixture.id).first()

        if not score:
            score = FixtureScore(
                fixture_id=fixture.id,
                home_halftime=score_info["halftime"]["home"],
                away_halftime=score_info["halftime"]["away"],
                home_fulltime=score_info["fulltime"]["home"],
                away_fulltime=score_info["fulltime"]["away"],
                home_extratime=score_info.get("extratime", {}).get("home"),
                away_extratime=score_info.get("extratime", {}).get("away"),
                home_penalty=score_info.get("penalty", {}).get("home"),
                away_penalty=score_info.get("penalty", {}).get("away")
            )
            db.add(score)
        else:
            score.home_halftime = score_info["halftime"]["home"]
            score.away_halftime = score_info["halftime"]["away"]
            score.home_fulltime = score_info["fulltime"]["home"]
            score.away_fulltime = score_info["fulltime"]["away"]
            score.updated_at = datetime.utcnow()

        db.commit()

        # Sync statistics (if fixture is finished)
        if fixture.status in ["FT", "AET", "PEN"]:
            await sync_fixture_statistics(db, fixture.id)

        await asyncio.sleep(0.5)  # Rate limiting

    logger.info(f"Synced {len(fixtures_data)} fixtures")


async def sync_fixture_statistics(db: Session, fixture_id: int):
    """Sync statistics for a fixture."""
    try:
        stats_data = await api_football_client.get_fixture_statistics(fixture_id)

        for team_stats in stats_data:
            team_id = team_stats["team"]["id"]
            statistics = {stat["type"]: stat["value"] for stat in team_stats["statistics"]}

            # Parse statistics
            fixture_stat = db.query(FixtureStat).filter_by(
                fixture_id=fixture_id,
                team_id=team_id
            ).first()

            if not fixture_stat:
                fixture_stat = FixtureStat(
                    fixture_id=fixture_id,
                    team_id=team_id
                )
                db.add(fixture_stat)

            # Map API stats to our model
            fixture_stat.shots_on_goal = statistics.get("Shots on Goal")
            fixture_stat.shots_off_goal = statistics.get("Shots off Goal")
            fixture_stat.total_shots = statistics.get("Total Shots")
            fixture_stat.blocked_shots = statistics.get("Blocked Shots")
            fixture_stat.shots_inside_box = statistics.get("Shots insidebox")
            fixture_stat.shots_outside_box = statistics.get("Shots outsidebox")
            fixture_stat.fouls = statistics.get("Fouls")
            fixture_stat.corners = statistics.get("Corner Kicks")
            fixture_stat.offsides = statistics.get("Offsides")

            # Parse possession (e.g., "65%")
            possession = statistics.get("Ball Possession", "0%")
            fixture_stat.ball_possession = int(possession.replace("%", ""))

            fixture_stat.yellow_cards = statistics.get("Yellow Cards")
            fixture_stat.red_cards = statistics.get("Red Cards")
            fixture_stat.goalkeeper_saves = statistics.get("Goalkeeper Saves")
            fixture_stat.total_passes = statistics.get("Total passes")
            fixture_stat.passes_accurate = statistics.get("Passes accurate")

            # Parse pass percentage
            passes_pct = statistics.get("Passes %", "0%")
            fixture_stat.passes_percentage = int(passes_pct.replace("%", ""))

            fixture_stat.expected_goals = statistics.get("expected_goals")  # May not be available
            fixture_stat.updated_at = datetime.utcnow()

        db.commit()
        logger.info(f"Synced statistics for fixture {fixture_id}")

    except Exception as e:
        logger.error(f"Error syncing statistics for fixture {fixture_id}: {str(e)}")


async def main(league_id: int, season: int):
    """Main sync function."""
    db = SessionLocal()

    try:
        logger.info(f"Starting historical data sync: League {league_id}, Season {season}")

        await sync_league(db, league_id, season)
        await sync_teams(db, league_id, season)
        await sync_fixtures(db, league_id, season)

        logger.info("Historical data sync completed successfully!")

    except Exception as e:
        logger.error(f"Error during sync: {str(e)}")
        raise

    finally:
        db.close()
        await api_football_client.close()


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Sync historical football data")
    parser.add_argument("--league", type=int, required=True, help="League ID (e.g., 39 for Premier League)")
    parser.add_argument("--season", type=int, required=True, help="Season year (e.g., 2023)")

    args = parser.parse_args()

    asyncio.run(main(args.league, args.season))
```


COMMON LEAGUE IDS:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
39  - Premier League (England)
140 - La Liga (Spain)
78  - Bundesliga (Germany)
135 - Serie A (Italy)
61  - Ligue 1 (France)
94  - Primeira Liga (Portugal)
88  - Eredivisie (Netherlands)
2   - UEFA Champions League
3   - UEFA Europa League
848 - UEFA Conference League
1   - World Cup
4   - Euro Championship


4.3 FIXTURES DATA MANAGEMENT
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

(Continued in next section due to length limits...)


TO BE CONTINUED: This tutorial covers approximately 30% of the complete build.
Remaining sections (Parts 5-12) will include:
- Live stats polling implementation
- Statistical models (Poisson, Dixon-Coles, Elo, Logistic)
- ML models (RandomForest, XGBoost)
- React frontend with Tailwind
- Tiered access implementation
- Docker deployment to GreenGeeks
- And more...

This is a production-grade foundation. Each subsequent section builds upon this base.
awesome â€” hereâ€™s your from-scratch, end-to-end, step-by-step build guide for a high-performance clone of www.superstatsfootball.com
 on Windows + Docker, with:

Python (FastAPI) backend

APIFootball ingestion (historical, fixtures, 1-second live stats)

Supabase (PostgreSQL, Realtime, RLS)

Rules/statistics models for users (Poisson, Dixon-Coles, Elo, Logistic Regression)

ML models for admin (RandomForest, XGBoost)

React + Tailwind UI matching your layout, with Settings, filters, Clear/Reset

Tiered access (Free + 4 plans) with league coverage

â€œOnly next roundâ€ fixture display

Admin debug panel

Deployment to GreenGeeks with Docker

0) Prereqs (Windows)

Install:

Docker Desktop (WSL2 enabled)

Node.js 18+ (for React build)

Git

Create Supabase project (Enterprise). Grab:

SUPABASE_DB_URL (Postgres connection string)

SUPABASE_ANON_KEY, SUPABASE_SERVICE_KEY

Get your APIFootball API key.

1) Monorepo layout
superstatsfootball/
  .env/                      # never commit, store runtime secrets here
    backend.env
    frontend.env
  docker/
    nginx/
      nginx.conf
  packages/
    backend/
      app/
        api/                # FastAPI routers
        core/               # domain logic (ratings/models)
        data/               # db access, ETL, schemas
        jobs/               # schedulers (live polling, rollups)
        models/             # ML artifacts, model registry
        services/           # apifootball client, caching, auth
        utils/
        main.py
      requirements.txt
      Dockerfile
    frontend/
      src/
        components/
        pages/
        store/
        utils/
      index.html
      package.json
      vite.config.ts
      tailwind.config.js
      postcss.config.js
      Dockerfile
  supabase/
    001_schema.sql
    002_rls.sql
    003_seed_plans.sql
    004_functions.sql
  docker-compose.yml
  README.md

2) Supabase schema (PostgreSQL + RLS)
2.1 Tables

Create with psql or Supabase SQL editor.

-- plans (Free + 4 paid)
CREATE TABLE plan (
  plan_id text PRIMARY KEY,          -- 'free','starter','analyst','pro','elite'
  name text NOT NULL,
  rank int NOT NULL                  -- 0..4
);

-- leagues (normalized)
CREATE TABLE league (
  league_id bigint PRIMARY KEY,
  country text NOT NULL,
  name text NOT NULL,
  -- optional meta fields...
  UNIQUE(country, name)
);

-- plan-league coverage
CREATE TABLE plan_league_access (
  plan_id text REFERENCES plan(plan_id) ON DELETE CASCADE,
  league_id bigint REFERENCES league(league_id) ON DELETE CASCADE,
  PRIMARY KEY (plan_id, league_id)
);

-- seasons (label like '2020/2021')
CREATE TABLE season (
  season_id text PRIMARY KEY,
  from_year int NOT NULL,
  to_year int NOT NULL
);

-- teams
CREATE TABLE team (
  team_id bigint PRIMARY KEY,
  name text NOT NULL,
  country text
);

-- matches (finished and fixtures unified; finished=1 when final)
CREATE TABLE match (
  match_id bigint PRIMARY KEY,
  league_id bigint REFERENCES league(league_id),
  season_id text REFERENCES season(season_id),
  date_utc timestamptz NOT NULL,
  round text,                         -- used for "next round"
  home_id bigint REFERENCES team(team_id),
  away_id bigint REFERENCES team(team_id),
  ft_home int, ft_away int,           -- null for upcoming
  ht_home int, ht_away int,
  finished boolean DEFAULT false,
  live boolean DEFAULT false,
  UNIQUE(league_id, date_utc, home_id, away_id)
);

-- per-match stats (atomic, extensible)
CREATE TABLE match_stat (
  match_id bigint REFERENCES match(match_id) ON DELETE CASCADE,
  stat text,                          -- 'shots_on','shots_off','possession','corners','yellows','reds','offsides',...
  home numeric,                       -- can be fractional if xG
  away numeric,
  updated_at timestamptz DEFAULT now(),
  PRIMARY KEY (match_id, stat)
);

-- predictions (per model, per market)
CREATE TABLE prediction (
  match_id bigint REFERENCES match(match_id) ON DELETE CASCADE,
  model text,             -- 'poisson','dixon_coles','elo','logreg','rf','xgb'
  version text,           -- 'v1.0.0', hash of params
  market text,            -- '1X2','OU25','BTTS','corners','cards',...
  selection text,         -- 'H','D','A' or 'Over','Under'
  prob numeric,           -- 0..1
  xg_home numeric, xg_away numeric,
  ci_low numeric, ci_high numeric,    -- confidence interval for prob (optional)
  created_at timestamptz DEFAULT now(),
  PRIMARY KEY (match_id, model, version, market, selection)
);

-- users / profiles (Supabase auth maps to this row)
CREATE TABLE profile (
  user_id uuid PRIMARY KEY,           -- equals auth.uid()
  email text UNIQUE,
  plan_id text REFERENCES plan(plan_id) DEFAULT 'free',
  is_admin boolean DEFAULT false,
  created_at timestamptz DEFAULT now()
);

2.2 Import league coverage

Convert your League_coverage_by_plan.csv into rows of (plan_id, league_id). One-off import:

-- seed plans
INSERT INTO plan(plan_id,name,rank) VALUES
 ('free','Free',0),('starter','Starter',1),('analyst','Analyst',2),
 ('pro','Pro',3),('elite','Elite',4)
ON CONFLICT DO NOTHING;


Then bulk import access with a CSV loader (psql \copy) or Supabase UI. Example:

\copy plan_league_access(plan_id, league_id) FROM 'League_coverage_by_plan.csv' CSV HEADER;

2.3 RLS (Row-Level Security)

Enable and add policies.

-- Enable RLS
ALTER TABLE league ENABLE ROW LEVEL SECURITY;
ALTER TABLE match ENABLE ROW LEVEL SECURITY;
ALTER TABLE match_stat ENABLE ROW LEVEL SECURITY;
ALTER TABLE prediction ENABLE ROW LEVEL SECURITY;

-- Helper view to get current user's plan
CREATE VIEW current_user_plan AS
  SELECT p.user_id, p.plan_id, p.is_admin
  FROM profile p
  WHERE p.user_id = auth.uid();

-- Only leagues accessible by plan
CREATE POLICY league_by_plan ON league
FOR SELECT USING (
  EXISTS (
    SELECT 1 FROM current_user_plan cup
    JOIN plan_league_access pla ON pla.plan_id = cup.plan_id
    WHERE pla.league_id = league.league_id
  )
  OR EXISTS (SELECT 1 FROM current_user_plan cup WHERE cup.is_admin)
);

-- Matches restricted by league coverage
CREATE POLICY match_by_plan ON match
FOR SELECT USING (
  EXISTS (
    SELECT 1 FROM current_user_plan cup
    JOIN plan_league_access pla ON pla.plan_id = cup.plan_id
    WHERE pla.league_id = match.league_id
  )
  OR EXISTS (SELECT 1 FROM current_user_plan cup WHERE cup.is_admin)
);

-- Stats & predictions follow matches
CREATE POLICY stat_by_plan ON match_stat
FOR SELECT USING (
  EXISTS (SELECT 1 FROM match m WHERE m.match_id = match_stat.match_id)
);

CREATE POLICY prediction_by_plan ON prediction
FOR SELECT USING (
  EXISTS (SELECT 1 FROM match m WHERE m.match_id = prediction.match_id)
);


For â€œcolumn-levelâ€ limits per tier, put restricted fields (e.g., xG) in a separate table with stricter RLS, or expose via views that hide columns for non-eligible plans.

2.4 Season retention (current + last 4)

Create a function and call daily:

CREATE OR REPLACE FUNCTION prune_old_seasons()
RETURNS void LANGUAGE plpgsql AS $$
DECLARE
  keep text[];
BEGIN
  -- compute the 5 most recent season_ids
  SELECT ARRAY(
    SELECT season_id FROM season ORDER BY to_year DESC LIMIT 5
  ) INTO keep;
  -- delete older
  DELETE FROM match WHERE season_id NOT IN (SELECT unnest(keep));
  DELETE FROM match_stat WHERE match_id NOT IN (SELECT match_id FROM match);
  DELETE FROM prediction WHERE match_id NOT IN (SELECT match_id FROM match);
END$$;


Schedule by calling this from backend daily (see Â§5).

3) Backend (FastAPI, Docker, Python)
3.1 Dockerfile & requirements

packages/backend/requirements.txt

fastapi==0.115.*
uvicorn[standard]==0.30.*
httpx==0.27.*
pydantic==2.*
psycopg[binary]==3.2.*
sqlalchemy==2.0.*
alembic==1.13.*
numpy==2.*
pandas==2.*
scikit-learn==1.5.*
xgboost==2.1.*
orjson==3.*
python-dotenv==1.0.*


packages/backend/Dockerfile

FROM python:3.11-slim

ENV PYTHONDONTWRITEBYTECODE=1 \
    PYTHONUNBUFFERED=1

WORKDIR /app
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

COPY app ./app

EXPOSE 8000
CMD ["uvicorn", "app.main:app", "--host","0.0.0.0","--port","8000","--workers","2"]

3.2 .env (runtime)

.env/backend.env (example)

API_FOOTBALL_KEY=your_key_here
DATABASE_URL=postgresql+psycopg://USER:PASSWORD@HOST:PORT/dbname
SUPABASE_ANON=...
SUPABASE_SERVICE=...
LIVE_POLL_INTERVAL_MS=1000
HOME_ELO_BONUS=100
ELO_K=20

3.3 Database access (SQLAlchemy)

app/data/db.py

from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker
import os

engine = create_engine(os.environ["DATABASE_URL"], pool_pre_ping=True)
SessionLocal = sessionmaker(bind=engine, autoflush=False, autocommit=False)

def get_db():
    db = SessionLocal()
    try: yield db
    finally: db.close()

3.4 APIFootball client

app/services/apifootball.py

import httpx, os, asyncio

API = "https://apiv3.apifootball.com/"
KEY = os.environ["API_FOOTBALL_KEY"]

async def get_events(from_date, to_date, league_id=None, live=False):
    params = {
      "action":"get_events",
      "from":from_date, "to":to_date,
      "APIkey": KEY
    }
    if league_id: params["league_id"] = league_id
    if live: params["match_live"] = 1
    async with httpx.AsyncClient(timeout=30) as client:
        r = await client.get(API, params=params)
        r.raise_for_status()
        return r.json()

async def get_statistics(match_id: int):
    async with httpx.AsyncClient(timeout=30) as client:
        r = await client.get(API, params={"action":"get_statistics","match_id":match_id,"APIkey":KEY})
        r.raise_for_status()
        return r.json()

3.5 ETL (historical & fixtures)

app/jobs/etl.py

from .apifootball import get_events, get_statistics
from sqlalchemy import insert
from ..data.db import get_db
from datetime import date, timedelta
import asyncio

async def load_season(league_id: int, season_from: str, season_to: str):
    # fetch in windows if needed
    events = await get_events(season_from, season_to, league_id=league_id)
    # map into tables (league, team, match)
    # upsert league/teams; insert matches; stats later
    ...

async def refresh_fixtures(league_ids: list[int], days_ahead: int = 7):
    today = date.today()
    events = []
    for lid in league_ids:
        ev = await get_events(today.isoformat(), (today+timedelta(days=days_ahead)).isoformat(), league_id=lid)
        events.extend(ev)
    # Upsert matches with finished=false, live=false
    ...

async def backfill_stats_for_finished(match_ids: list[int]):
    for mid in match_ids:
        stats = await get_statistics(mid)
        # upsert into match_stat rows
        ...

3.6 Live engine (1-second polling)

app/jobs/live.py

import os, asyncio
from .apifootball import get_events, get_statistics
from ..data.db import get_db
from sqlalchemy import update

INTERVAL = int(os.getenv("LIVE_POLL_INTERVAL_MS","1000"))

async def live_loop():
    while True:
        try:
            live = await get_events(from_date="2025-01-01", to_date="2025-12-31", live=True)
            # update match scores, time, live flag, stats
            # minimal writes (only changed fields); commit batched
            ...
        except Exception as e:
            # log
            ...
        await asyncio.sleep(INTERVAL/1000)


Hook it on startup:

app/main.py

from fastapi import FastAPI
import asyncio
from .jobs.live import live_loop

app = FastAPI(title="SuperStatsFootball API")

@app.on_event("startup")
async def startup():
    asyncio.create_task(live_loop())


If you prefer: run live_loop() in a dedicated worker container so the API workers remain lean.

3.7 Prediction models (users vs admin)
Poisson (goals baseline)

app/core/models/poisson.py

import numpy as np
from math import exp, factorial

def team_strengths(matches):
    # compute attack/defense strengths per team (home/away split), league avg, time decay
    ...

def poisson_pmf(k, lam): return exp(-lam) * (lam**k) / factorial(k)

def outcome_probs(lh, la, maxg=10):
    # bivariate independent Poisson for score grid
    pH=pD=pA=0.0
    for x in range(maxg+1):
        px = poisson_pmf(x, lh)
        for y in range(maxg+1):
            py = poisson_pmf(y, la)
            if x>y: pH += px*py
            elif x==y: pD += px*py
            else: pA += px*py
    return pH, pD, pA

Dixonâ€“Coles correction

app/core/models/dixon_coles.py

from .poisson import poisson_pmf

def dc_adjustment(x,y,lam,mu,rho):
    if x==0 and y==0: return 1 - lam*mu*rho
    if x==0 and y==1: return 1 + lam*rho
    if x==1 and y==0: return 1 + mu*rho
    if x==1 and y==1: return 1 - rho
    return 1.0

def outcome_probs_dc(lh, la, rho, maxg=10):
    pH=pD=pA=0.0
    for x in range(maxg+1):
        px = poisson_pmf(x, lh)
        for y in range(maxg+1):
            py = poisson_pmf(y, la)
            adj = dc_adjustment(x,y,lh,la,rho)
            p = px*py*adj
            if x>y: pH+=p
            elif x==y: pD+=p
            else: pA+=p
    # normalize small drift
    s = pH+pD+pA
    return pH/s, pD/s, pA/s


Fit rho and strengths by maximizing (weighted) likelihood with exponential time decay. Cache by league.

Elo

app/core/models/elo.py

HOME_BONUS = 100
K = 20

def win_prob(Rh, Ra, home=True):
    Rh_adj = Rh + (HOME_BONUS if home else 0)
    return 1 / (1 + 10 ** ((Ra - Rh_adj)/400))

def update(Rh, Ra, result):  # result: 1=home win, 0.5=draw, 0=away win
    pH = win_prob(Rh, Ra, home=True)
    expected = 1*pH + 0.5*(1 - pH - pH)  # simple; or handle draw explicitly
    d = K * (result - expected)
    return Rh + d, Ra - d


Maintain Elo per team by league; recompute predictions via win_prob.

Logistic Regression (multinomial)

app/core/models/logreg.py

import numpy as np
from sklearn.linear_model import LogisticRegression

class Logit1X2:
    def __init__(self):
        self.model = LogisticRegression(multi_class='multinomial', max_iter=1000)

    def fit(self, X, y): self.model.fit(X,y)
    def predict_proba(self, X): return self.model.predict_proba(X)
    def feature_importance(self): return self.model.coef_


Features: Elo diff, last-N form, avg goals for/against, xG (if available), home flag, etc.

RandomForest / XGBoost (admin)

app/core/models/ensemble.py

from sklearn.ensemble import RandomForestClassifier
import xgboost as xgb
import numpy as np

class RF1X2:
    def __init__(self, **kw): self.clf = RandomForestClassifier(n_estimators=600, max_depth=None, **kw)
    def fit(self,X,y): self.clf.fit(X,y)
    def predict_proba(self,X): return self.clf.predict_proba(X)

class XGB1X2:
    def __init__(self, **kw): self.clf = xgb.XGBClassifier(
        n_estimators=800, learning_rate=0.05, max_depth=6, subsample=0.9, colsample_bytree=0.9, tree_method="hist", **kw)
    def fit(self,X,y): self.clf.fit(X,y, eval_metric="mlogloss")
    def predict_proba(self,X): return self.clf.predict_proba(X)

Prediction service & confidence intervals

app/core/predict.py

import numpy as np
from scipy.stats import binom

def ci_wilson(p, n, z=1.96):
    denom = 1 + z*z/n
    centre = p + z*z/(2*n)
    pm = z * ((p*(1-p) + z*z/(4*n))/n)**0.5
    return max(0,(centre-pm)/denom), min(1,(centre+pm)/denom)

def predict_match(match, model, training_data):
    # compute probs per selected model
    if model=="poisson": ...
    elif model=="dixon_coles": ...
    elif model=="elo": ...
    elif model=="logreg": ...
    elif model=="rf": ...
    elif model=="xgb": ...
    # compute CI using sample size n from training_data size
    n = len(training_data)
    pH,pD,pA = ...
    ciH = ci_wilson(pH, n)
    return dict(H=pH, D=pD, A=pA, ciH=ciH, xg_home=..., xg_away=...)

API endpoints

app/api/routes.py

from fastapi import APIRouter, Depends
from ..data.db import get_db

router = APIRouter(prefix="/api")

@router.post("/ingest/historical")
async def ingest_historical(body: dict, db=Depends(get_db)):
    # loop seasons & leagues, call load_season
    ...

@router.post("/ingest/fixtures")
async def ingest_fixtures(body: dict, db=Depends(get_db)):
    ...

@router.post("/predictions")
async def predictions(body: dict, db=Depends(get_db)):
    """
    body = { leagues:[...], seasons:[...], model:"poisson" | "elo" | ..., round:"next" }
    """
    # fetch upcoming matches for rounds (see Â§4.3)
    # load training data with filters -> compute predictions -> write to prediction table and return
    ...

@router.post("/admin/retrain")
async def admin_retrain(body: dict, db=Depends(get_db)):
    # train or refresh ML models; gated by admin token
    ...

@router.post("/admin/toggle-debug")
async def toggle_debug():
    ...


Register routes in main.py.

4) Logic details & data rules
4.1 â€œOnly next roundâ€ fixtures

For each league, determine next round:

If API provides match_round like â€œRound 12â€, compute the minimum future round and select those matches.

If no round, take earliest future date per league and select matches for that date.

SQL helper view:

CREATE VIEW next_round_matches AS
SELECT m.*
FROM match m
JOIN (
  SELECT league_id,
         MIN(date_utc::date) AS d
  FROM match
  WHERE finished = false
  GROUP BY league_id
) x ON x.league_id = m.league_id AND m.date_utc::date = x.d
WHERE m.finished = false;


The API can query this view (RLS still applies).

4.2 Settings â†’ recompute

Frontend sends selected countries/leagues, seasons, model.

Backend pulls training subset (only those seasons) and upcoming matches for selected leagues.

Compute predictions and upsert into prediction with model,version keyed.

Return predictions for immediate render.

4.3 Tier gating

RLS ensures users cannot fetch leagues outside their plan.

Frontend additionally hides locked tabs/columns and shows â€œupgradeâ€ locks.

Admin sees all tabs plus Debug.

5) Jobs & housekeeping

Historical load: one-off: loop last 4 seasons + current for target leagues.

Daily refresh: fixtures (+7 days), results from yesterday, stats for finished; call prune_old_seasons().

Live loop: every 1s, update live scores/stats.

Model refresh: nightly, refit DC, LogReg; store model version hash (params) in a small model_registry table.

You can run jobs:

as background tasks in backend container, or

as a dedicated worker service in docker-compose.

6) Frontend (React + Tailwind)
6.1 Bootstrap
cd packages/frontend
npm create vite@latest . -- --template react-ts
npm i @supabase/supabase-js axios clsx jotai
npm i -D tailwindcss postcss autoprefixer
npx tailwindcss init -p


tailwind.config.js

export default {
  content: ["./index.html","./src/**/*.{ts,tsx}"],
  theme: { extend: {} },
  plugins: [],
}


src/index.css add @tailwind base; @tailwind components; @tailwind utilities;

6.2 Supabase client

src/utils/supa.ts

import { createClient } from '@supabase/supabase-js'
export const supa = createClient(
  import.meta.env.VITE_SUPABASE_URL!,
  import.meta.env.VITE_SUPABASE_ANON!
)

6.3 App skeleton (tabs + settings)

src/pages/App.tsx

import { useState } from "react"
import SettingsPanel from "../components/SettingsPanel"
import Tab1X2 from "../components/tabs/Tab1X2"
import TabGoals from "../components/tabs/TabGoals"
import AdminDebug from "../components/AdminDebug"

export default function App(){
  const [active, setActive] = useState<"settings"|"1x2"|"goals"|"corners"|"cards">("settings")
  const [model, setModel] = useState<"poisson"|"dixon_coles"|"elo"|"logreg"|"rf"|"xgb">("poisson")
  const [filters, setFilters] = useState({ countries:[], leagues:[], seasons:[] })

  return (
    <div className="min-h-screen bg-slate-950 text-slate-100">
      <header className="p-4 flex items-center justify-between border-b border-slate-800">
        <h1 className="text-xl font-bold">SuperStatsFootball</h1>
        <nav className="flex gap-2">
          {["settings","1x2","goals","corners","cards"].map(t => (
            <button key={t} onClick={()=>setActive(t as any)}
              className={`px-3 py-1 rounded ${active===t?'bg-emerald-600':'bg-slate-800 hover:bg-slate-700'}`}>
              {t.toUpperCase()}
            </button>
          ))}
        </nav>
      </header>

      <main className="p-4">
        {active==="settings" && <SettingsPanel model={model} setModel={setModel} filters={filters} setFilters={setFilters} />}
        {active==="1x2" && <Tab1X2 model={model} filters={filters} />}
        {active==="goals" && <TabGoals model={model} filters={filters} />}
        {/* add Corners/Cards tabs similarly */}
        <AdminDebug />
      </main>
    </div>
  )
}

6.4 Settings panel (with Clear)

src/components/SettingsPanel.tsx

import { useState } from "react"
import axios from "axios"

export default function SettingsPanel({model,setModel,filters,setFilters}:{model:any,setModel:any,filters:any,setFilters:any}){
  const [busy,setBusy] = useState(false)

  async function apply(){
    setBusy(true)
    await axios.post("/api/predictions", {
      model,
      leagues: filters.leagues,
      seasons: filters.seasons
    })
    setBusy(false)
  }
  function clearAll(){
    setFilters({countries:[], leagues:[], seasons:[]})
    setModel("poisson")
  }
  return (
    <div className="grid md:grid-cols-3 gap-4">
      <section className="p-3 bg-slate-900 rounded">
        <h2 className="font-semibold mb-2">Model</h2>
        <select className="w-full bg-slate-800 p-2 rounded" value={model} onChange={e=>setModel(e.target.value as any)}>
          <option value="poisson">Poisson</option>
          <option value="dixon_coles">Dixon-Coles</option>
          <option value="elo">Elo</option>
          <option value="logreg">Logistic Regression</option>
          <option value="rf">Random Forest (admin)</option>
          <option value="xgb">XGBoost (admin)</option>
        </select>
      </section>
      <section className="p-3 bg-slate-900 rounded md:col-span-2">
        <h2 className="font-semibold mb-2">Filters</h2>
        {/* render checkboxes from API: countries/leagues; seasons */}
        {/* ... */}
      </section>
      <div className="md:col-span-3 flex gap-2">
        <button onClick={apply} disabled={busy} className="px-4 py-2 bg-emerald-600 rounded">{busy?'Analyzingâ€¦':'Analyze'}</button>
        <button onClick={clearAll} className="px-4 py-2 bg-slate-700 rounded">Clear</button>
      </div>
    </div>
  )
}

6.5 1X2 tab (pull predictions)

src/components/tabs/Tab1X2.tsx

import { useEffect, useState } from "react"
import axios from "axios"

export default function Tab1X2({model,filters}:{model:string,filters:any}){
  const [rows,setRows] = useState<any[]>([])
  useEffect(()=>{
    let cancelled=false
    ;(async()=>{
      const {data} = await axios.post("/api/predictions", {
        model, leagues: filters.leagues, seasons: filters.seasons
      })
      if(!cancelled) setRows(data.rows)
    })()
    return ()=>{cancelled=true}
  },[model, JSON.stringify(filters)])
  return (
    <div className="overflow-auto">
      <table className="min-w-[900px] w-full text-sm">
        <thead className="bg-slate-900">
          <tr>
            <th className="p-2">League</th>
            <th>Kickoff</th><th>Home</th><th>Away</th>
            <th>H%</th><th>D%</th><th>A%</th>
            <th>xG(H)</th><th>xG(A)</th>
            <th>CI(H)</th>
          </tr>
        </thead>
        <tbody>
          {rows.map((r,i)=>(
            <tr key={i} className="border-b border-slate-800">
              <td className="p-2">{r.league_name}</td>
              <td>{new Date(r.date_utc).toLocaleString()}</td>
              <td>{r.home}</td><td>{r.away}</td>
              <td>{(r.prob.H*100).toFixed(1)}</td>
              <td>{(r.prob.D*100).toFixed(1)}</td>
              <td>{(r.prob.A*100).toFixed(1)}</td>
              <td>{r.xg_home.toFixed(2)}</td>
              <td>{r.xg_away.toFixed(2)}</td>
              <td>{(r.ciH[0]*100).toFixed(0)}â€“{(r.ciH[1]*100).toFixed(0)}%</td>
            </tr>
          ))}
        </tbody>
      </table>
    </div>
  )
}

6.6 Realtime live updates (scores/stats)

Subscribe to changes:

import { useEffect } from "react"
import { supa } from "../../utils/supa"

useEffect(()=>{
  const sub = supa.channel("schema-db-changes")
    .on("postgres_changes", {event:"UPDATE", schema:"public", table:"match"}, (payload)=>{
      // merge live score/time into UI state
    })
    .subscribe()
  return ()=>{supa.removeChannel(sub)}
},[])

7) Metrics & transparency

Add an Evaluation endpoint to compute Brier and LogLoss over a backtest window; display summary in admin Debug tab.

import numpy as np

def brier(y_onehot, p):      # y_onehot: [0,0,1] true class
    return np.mean(np.sum((p - y_onehot)**2, axis=1))

def logloss(y_idx, p, eps=1e-12):
    return -np.mean(np.log(np.take_along_axis(p, y_idx[:,None], axis=1).clip(eps)))


Expose /admin/evaluate?model=...&from=...&to=....

8) Docker Compose

docker-compose.yml

version: "3.9"
services:
  backend:
    build: ./packages/backend
    env_file: ./.env/backend.env
    ports: ["8000:8000"]
    restart: unless-stopped

  frontend:
    build: ./packages/frontend
    environment:
      - VITE_SUPABASE_URL=${VITE_SUPABASE_URL}
      - VITE_SUPABASE_ANON=${VITE_SUPABASE_ANON}
    ports: ["5173:5173"]
    command: ["npm","run","dev"]  # for local; production uses nginx

  nginx:
    image: nginx:alpine
    volumes:
      - ./docker/nginx/nginx.conf:/etc/nginx/nginx.conf:ro
    ports:
      - "80:80"
    depends_on: [backend]


Production: build frontend and serve static via Nginx; proxy /api to backend.

docker/nginx/nginx.conf

events {}
http {
  server {
    listen 80;
    server_name _;
    location / {
      root /usr/share/nginx/html;
      try_files $uri /index.html;
    }
    location /api/ {
      proxy_pass http://backend:8000/api/;
    }
  }
}


Build production frontend image with npm run build and copy dist/ into nginx image or use a multi-stage Dockerfile for frontend.

9) Deployment to GreenGeeks

Best path: a VPS plan (SSH + Docker). Steps:

Push images to Docker Hub (or GHCR).

docker build -t youruser/ssf-backend:1.0 ./packages/backend
docker push youruser/ssf-backend:1.0
# build frontend nginx image that serves built /dist and proxies /api to backend host


On GreenGeeks VPS:

Install Docker & docker-compose.

Pull images: docker pull youruser/ssf-backend:1.0 and your frontend image.

Create a production docker-compose.yml with Nginx reverse-proxy (80/443), backend, and optional Certbot or use Caddy for auto-SSL.

Domain: Point A record to server IP. Issue Letâ€™s Encrypt (Caddy makes this trivial).

Set environment vars with secure secrets (.env files) and restart: unless-stopped.

Migrations: run schema SQL via Supabase SQL editor. Seed plans and coverage CSV.

Smoke test: API /api/predictions returns data; UI loads at domain.

If you must use shared hosting (cPanel): container support is limited; deploy backend separately (small VPS), point front-end at that API URL, and host static site at GreenGeeks. SSL terminate at CDN/Cloudflare if desired.

10) Admin vs Regular user (what changes)

Regular user:

Can select models: Poisson, Dixon-Coles, Elo, Logistic Regression.

Limited leagues/tabs/columns by plan (RLS + UI gating).

No Debug tab.

Admin:

Sees all leagues & tabs.

Extra models: RandomForest, XGBoost.

Admin Debug: toggle live logs, view raw model features, run /admin/retrain, backtests, feature importances/coefficients.

Can switch models on the fly and view explainability (coefficients for LogReg, feature importance/SHAP for RF/XGB, DC rho, Elo ratings).

11) â€œNext Roundâ€ UX and Clear button

The Settings tab controls:

Checkboxes for countries â†’ leagues, seasons

Model selector

Analyze triggers /api/predictions recompute

Clear resets selections & model, clears cached predictions in UI (server keeps previous prediction rows but UI ignores)

Upcoming view shows (by country â†’ league):

Only next round matches (via view/endpoint)

Probabilities, xG, confidence intervals; live badge for in-play

12) Testing & quality gates

Unit tests: Poisson/DC, Elo updates, LogReg inference

Integration: ETL from API â†’ DB, predictions round-trip

Backtests: at least last 2 seasons per major league; report Brier & LogLoss

Calibration: reliability diagrams; optional isotonic/Platt scaling for ML

Performance: cache training artifacts per league + model; vectorize Poisson grids; guard live loop minimal writes

Quick commands

Local dev

docker compose up --build
# frontend at http://localhost:5173
# backend  at http://localhost:8000/docs


Seed Supabase

Run supabase/001_schema.sql, 002_rls.sql, 003_seed_plans.sql

Import League_coverage_by_plan.csv into plan_league_access

Initial ingest

POST /api/ingest/historical with {leagues:[...], seasons:["2020/2021",...,"2024/2025"]}

POST /api/ingest/fixtures with {leagues:[...], days_ahead:7}

Predictions

POST /api/predictions with {"model":"poisson","leagues":[...],"seasons":["2023/2024","2024/2025"]}

What to do next (fastest path to first result)

Stand up Supabase schema + RLS, seed plans and coverage.

Run backend & implement Poisson and Elo first.

Build Settings + 1X2 tab; wire /api/predictions.

Add Dixon-Coles + Logistic Regression.

Turn on live loop (1s) and Supabase Realtime subscription in UI.

Add admin-only RF/XGB + Debug tab.

Deploy to VPS (GreenGeeks) with Docker + Nginx/Caddy.



this is my website www.superstatsfootball.com and i have access to cpanel, to install apps, i have pro plan subscription on GreenGeeks.
